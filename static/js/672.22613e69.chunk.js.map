{"version":3,"file":"static/js/672.22613e69.chunk.js","mappings":"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","sources":["components/markdown/Node.ts","components/markdown/UlNodeProcessor.ts","components/markdown/MarkdownRenderer.tsx","components/markdown/ConvertToBarGraph.ts","pages/MarkdownEditorPage.tsx"],"sourcesContent":["import cheerio from 'cheerio';\r\n\r\n/*\r\n * A TextElement is a simple node that does not need complex processing.\r\n */\r\nexport type TextElement = DomElement;\r\n\r\n/*\r\n * MbNode (MarkBindNode) is an element that can be operated on by cheerio and our own node processing\r\n * methods. It must have a name (used to identify what kind of node it is), attributes (possibly empty),\r\n * and children nodes (possibly empty). This type allows us to assert that these attributes exist.\r\n */\r\nexport type MbNode = TextElement & cheerio.Element & {\r\n  name: string,\r\n  attribs: Record<string, any>,\r\n  children: NodeOrText[],\r\n};\r\n\r\n/*\r\n * NodeOrText is used before a node can be casted to either TextElement or MbNode.\r\n */\r\nexport type NodeOrText = TextElement | MbNode;\r\n\r\n/**\r\n * Utility function for converting HTML string to a node or text element.\r\n */\r\nexport function parseHTML(html: string) {\r\n  const node = cheerio.parseHTML(html);\r\n  return node as unknown as NodeOrText[];\r\n}\r\n\r\n\r\nexport interface DomElement {\r\n  attribs?: { [s: string]: string } | undefined;\r\n  children?: DomElement[] | undefined;\r\n  data?: any;\r\n  name?: string | undefined;\r\n  next?: DomElement | undefined;\r\n  parent?: DomElement | undefined;\r\n  prev?: DomElement | undefined;\r\n  type?: string | undefined;\r\n}\r\n\r\nexport function convertBackToHtml(nodes: NodeOrText[]): string {\r\n  const $ = cheerio.load('<body></body>'); // initialize Cheerio with an empty body tag\r\n\r\n  const body = $('body'); // get a reference to the body\r\n\r\n  nodes.forEach((node) => {\r\n    // If the node is a MbNode, reconstruct its HTML representation\r\n    if ('name' in node) {\r\n      const element = $(`<${node.name}>`);\r\n      for (const attr in node.attribs) {\r\n        element.attr(attr, node.attribs[attr]);\r\n      }\r\n\r\n      if (node.children) { // check if children are defined before recursive call\r\n        element.append(convertBackToHtml(node.children));\r\n      }\r\n\r\n      body.append(element); // append the element to the body\r\n    }\r\n    // If the node is a TextElement, simply add its data\r\n    else if ('data' in node) {\r\n      body.append(node.data); // append the data to the body\r\n    }\r\n  });\r\n\r\n  return $.html(); // returns the HTML string\r\n}\r\n","import { EmojiConvertor } from 'emoji-js';\r\nimport { NodeOrText } from './Node';\r\nimport isNumber from 'lodash/isNumber';\r\nimport isString from 'lodash/isString';\r\n\r\ninterface IconAttributes {\r\n  icon?: string;\r\n  iconSize?: string;\r\n  className?: string;\r\n}\r\n\r\ntype Size = {\r\n  fontSize: string;\r\n  imageSize: string;\r\n  squareSize: string;\r\n};\r\n\r\nfunction updateNodeRelations(iChild: NodeOrText, divChild: NodeOrText, children: NodeOrText[]): void {\r\n  iChild.next = divChild;\r\n  divChild.prev = iChild;\r\n\r\n  children.forEach((child) => {\r\n    child.parent = divChild;\r\n  });\r\n}\r\n\r\nfunction getStyleObject(node: NodeOrText): { [key: string]: string } {\r\n  let styleObject: { [key: string]: string } = {};\r\n  if (node.attribs?.style) {\r\n    const { style } = node.attribs;\r\n    styleObject = style.split(';').reduce((acc: Record<string, string>, rule: string) => {\r\n      const [property, value] = rule.split(':').map((str: string) => str.trim());\r\n      if (property) acc[property] = value;\r\n      return acc;\r\n    }, {});\r\n  }\r\n  return styleObject;\r\n}\r\n\r\nfunction createStyleString(styleObject: { [key: string]: string }): string {\r\n  return Object.entries(styleObject).map(\r\n    ([property, value]: [string, string]) => `${property}: ${value}`).join('; ');\r\n}\r\n\r\nfunction createIChild(\r\n  parent: NodeOrText,\r\n  icon: string,\r\n  size: Size,\r\n  className?: string,\r\n): NodeOrText {\r\n  const emoji = new EmojiConvertor();\r\n  emoji.replace_mode = 'unified';\r\n  emoji.allow_native = true;\r\n\r\n  const emojiString = `:${icon}:`;\r\n  const unicodeEmoji = emoji.replace_colons(emojiString);\r\n\r\n  const isEmoji = unicodeEmoji !== emojiString;\r\n  const localFileRegex = /^(\\.\\/)?[a-zA-Z0-9\\-._~:/?#[\\]@!$&'()*+,;=%]+\\.(jpg|png|gif|bmp|svg|jpeg)$/;\r\n  const urlRegex = /^(http(s)?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/;\r\n  const isImage = !isEmoji && (localFileRegex.test(icon) || urlRegex.test(icon));\r\n\r\n  let child: NodeOrText;\r\n  const defaultSize = `width: ${size.squareSize}; height: ${size.squareSize}; \r\n          margin-right:5px;text-align:center;display:flex;align-items:center;`;\r\n\r\n  if (isEmoji) {\r\n    child = {\r\n      type: 'tag',\r\n      name: 'span',\r\n      attribs: {\r\n        ...className && { class: className },\r\n        'aria-hidden': 'true',\r\n        style: `${defaultSize}${size.fontSize ? `font-size:${size.fontSize};\r\n        margin-right: 5px;` : 'margin-right: 5px;'}`,\r\n      },\r\n      children: [\r\n        {\r\n          type: 'text',\r\n          data: unicodeEmoji,\r\n        },\r\n      ],\r\n      next: undefined,\r\n      prev: undefined,\r\n      parent,\r\n    };\r\n  } else if (isImage) {\r\n    const altText = icon.split('/').pop()?.split('.')[0] || '';\r\n    const divNode: NodeOrText = {\r\n      type: 'tag',\r\n      name: 'div',\r\n      attribs: {\r\n        style: 'padding-bottom: 0.2rem;',\r\n      },\r\n      children: [],\r\n      next: undefined,\r\n      prev: undefined,\r\n      parent,\r\n    };\r\n\r\n    const imgNode: NodeOrText = {\r\n      type: 'tag',\r\n      name: 'img',\r\n      attribs: {\r\n        ...className && { class: className },\r\n        src: icon,\r\n        alt: altText,\r\n        style: defaultSize,\r\n      },\r\n      children: [],\r\n      next: undefined,\r\n      prev: undefined,\r\n      parent: divNode,\r\n    };\r\n    divNode.children?.push(imgNode);\r\n    child = divNode;\r\n  } else {\r\n    child = {\r\n      type: 'tag',\r\n      name: 'i',\r\n      attribs: {\r\n        class: className ? `${icon} ${className}` : icon,\r\n        'aria-hidden': 'true',\r\n        style: `${defaultSize}margin-right:5px;${size.fontSize ? `font-size:${size.fontSize};` : ''}`,\r\n      },\r\n      children: [],\r\n      next: undefined,\r\n      prev: undefined,\r\n      parent,\r\n    };\r\n  }\r\n  return child;\r\n}\r\n\r\nfunction getSize(iconSizeInput = '25px') {\r\n  let iconSize = iconSizeInput;\r\n  if (isNumber(iconSize)) {\r\n    // If iconSize is a number, convert it to a string and add 'px'\r\n    iconSize = `${iconSize}px`;\r\n  } else if (!isString(iconSize) || !/^\\d+px$/.test(iconSize)) {\r\n    // If iconSize is not a string in the format 'nnnpx', default to '25px'\r\n    iconSize = '25px';\r\n  }\r\n  // Remove 'px' from the end and convert to a number\r\n  const n = Number(iconSize.slice(0, -2));\r\n\r\n  // Calculate fontSize based on the size of the square and image.\r\n  // The multiplier (0.64) is approximated from the relationship in the provided sizes.\r\n  let fontSize = 16 + (n - 25) * 0.64;\r\n\r\n  // Make sure fontSize doesn't go below 16\r\n  fontSize = Math.max(fontSize, 16);\r\n\r\n  return {\r\n    fontSize: `${fontSize}px`,\r\n    imageSize: iconSize,\r\n    squareSize: iconSize,\r\n  };\r\n}\r\n\r\nfunction createDivChild(parent: NodeOrText, children: NodeOrText[]): NodeOrText {\r\n  return {\r\n    type: 'tag',\r\n    name: 'div',\r\n    attribs: {},\r\n    children,\r\n    next: undefined,\r\n    prev: undefined,\r\n    parent,\r\n  };\r\n}\r\n\r\nfunction updateNodeStyle(node: NodeOrText) {\r\n  const styleObject = getStyleObject(node);\r\n  styleObject['list-style-type'] = 'none';\r\n  styleObject['padding-left'] = '0';\r\n  if (!node.attribs) node.attribs = {};\r\n\r\n  node.attribs.style = createStyleString(styleObject);\r\n}\r\n\r\nfunction updateLiChildren(child: NodeOrText, parentIconAttributes:\r\nIconAttributes, defaultLiIconAttributes: IconAttributes) {\r\n  const icon = child.attribs?.icon || parentIconAttributes.icon || defaultLiIconAttributes.icon;\r\n  const iconSize = child.attribs?.size || parentIconAttributes.iconSize || defaultLiIconAttributes.iconSize;\r\n  const className = child.attribs?.class\r\n                        || parentIconAttributes.className\r\n                        || defaultLiIconAttributes.className;\r\n\r\n  if (child.attribs?.icon) delete child.attribs.icon;\r\n  if (child.attribs?.size) delete child.attribs.size;\r\n  if (child.attribs?.class) delete child.attribs.class;\r\n\r\n  const size = getSize(iconSize);\r\n\r\n  const iChild: NodeOrText = createIChild(child, icon, size, className);\r\n  const divChild: NodeOrText = createDivChild(child, child.children || []);\r\n  child.children = [iChild, divChild];\r\n  updateNodeRelations(iChild, divChild, child.children || []);\r\n  if (!child.attribs) child.attribs = {};\r\n  child.attribs.style = 'display: flex;';\r\n}\r\n\r\nexport function processUlNode(node: NodeOrText): NodeOrText {\r\n  const iconUl = node.attribs?.icon;\r\n  const hasIconInChildren = node.children?.find(\r\n    (child: NodeOrText) => child.name === 'li' && child.attribs?.icon,\r\n  );\r\n  if (iconUl === undefined && hasIconInChildren === undefined) return node;\r\n\r\n  if ('name' in node && node.name === 'ul') {\r\n    const iconAttributes: IconAttributes = {\r\n      icon: iconUl,\r\n      iconSize: node.attribs?.size,\r\n      className: node.attribs?.class,\r\n    };\r\n\r\n    if (iconAttributes.icon) delete node.attribs?.icon;\r\n    if (iconAttributes.iconSize) delete node.attribs?.size;\r\n    if (iconAttributes.className) delete node.attribs?.class;\r\n\r\n    let defaultLiIcon: IconAttributes = {};\r\n    if (hasIconInChildren) {\r\n      defaultLiIcon = {\r\n        icon: hasIconInChildren.attribs?.icon,\r\n        iconSize: hasIconInChildren.attribs?.size,\r\n        className: hasIconInChildren.attribs?.class,\r\n      };\r\n    }\r\n\r\n    if (iconAttributes.icon || hasIconInChildren) {\r\n      updateNodeStyle(node);\r\n      node.children = node.children?.map((child: NodeOrText) => {\r\n        if (child.name === 'li') {\r\n          updateLiChildren(child, iconAttributes, defaultLiIcon);\r\n        }\r\n        return child;\r\n      }) || [];\r\n    }\r\n  }\r\n  return node;\r\n}\r\n","import React from 'react';\r\nimport MarkdownIt from 'markdown-it';\r\nimport MarkdownItAttrs from 'markdown-it-attrs';\r\nimport Prism from 'prismjs';\r\nimport { html as html_beautify } from 'js-beautify';\r\nimport 'prismjs/themes/prism.css';  // Choose the theme you like\r\nimport { Row, Col } from 'antd';\r\nimport { convertBackToHtml, parseHTML } from './Node';\r\nimport { processUlNode } from './UlNodeProcessor';\r\nimport { convertToBarGraph } from './ConvertToBarGraph';\r\n\r\n\r\n\r\n\r\nconst md = new MarkdownIt();\r\nmd.use(MarkdownItAttrs);\r\ninterface UlObject {\r\n  index: number,\r\n  map: number[],\r\n  token: any, // Replace 'any' with actual token type\r\n  pTag: boolean,\r\n  atIndex: number\r\n}\r\nmd.core.ruler.push('modify_tokens', (state: any) => { // Replace 'any' with actual state type\r\n  let ulList: UlObject[] = [];\r\n  let resultUl: UlObject[] = [];\r\n\r\n  //Locate all the element with p tag and non p tag\r\n  state.tokens.forEach((token: any, index: number) => { // Replace 'any' with actual token type\r\n    if (token.type === 'bullet_list_open') {\r\n      ulList.push({ index: index, map: [...token.map], token, pTag: false, atIndex: -1 });\r\n    } else if (token.type === 'bullet_list_close') {\r\n      let curUl = ulList.pop();\r\n\r\n      if (curUl != null) {\r\n\r\n      if (curUl.token.attrs !== null) {\r\n        curUl.map[0] = curUl.map[0] + 1;\r\n        if (ulList.length > 0) {\r\n          ulList[ulList.length - 1].map[0] = curUl.map[0] + 1;\r\n        } else {\r\n          curUl.map[0] = curUl.map[0] + 1;\r\n        }\r\n      }\r\n      else {\r\n        if (ulList.length > 0) {\r\n          ulList[ulList.length - 1].map[0] = curUl.map[0];\r\n        }\r\n      }\r\n        resultUl.push(curUl);\r\n      }\r\n\r\n\r\n    } else if (token.type === \"inline\") {\r\n      if (ulList.length > 0) {  // check that ulList is not empty\r\n        if (ulList[ulList.length - 1].map[0] >= token.map[0]) {\r\n          ulList[ulList.length - 1].map[0] = token.map[1];\r\n        } else {\r\n          ulList[ulList.length - 1].pTag = true;\r\n          ulList[ulList.length - 1].atIndex = index;\r\n          ulList[ulList.length - 1].map[0] = token.map[1];\r\n        }\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  //apply the resultUl \r\n  let newTokens: any[] = []; // Replace 'any' with actual token type\r\n\r\n  state.tokens.forEach((token: any, index: number) => { // Replace 'any' with actual token type\r\n    // Check if the token is a paragraph\r\n    if (token.type === 'paragraph_open' || token.type === 'paragraph_close') {\r\n      // Locate the corresponding ul object in resultUl based on the token's level\r\n      const matchingUl = resultUl.find(ul => ul.token.level === token.level - 2);\r\n\r\n      // If a matching ul object is found and it has pTag set to true\r\n      if (matchingUl) {\r\n        if (matchingUl.pTag) {\r\n          newTokens.push(token);\r\n        }\r\n      } else {\r\n        newTokens.push(token);\r\n      }\r\n    } else {\r\n      newTokens.push(token);\r\n    }\r\n  });\r\n\r\n  state.tokens = newTokens;\r\n});\r\n\r\ninterface MarkdownRendererProps {\r\n  markdown: string;\r\n}\r\n\r\nconst MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ markdown }) => {\r\n\r\n  let renderedMarkdown = md.render(markdown);\r\n\r\n  console.log(\"renderedMarkdown\", renderedMarkdown);\r\n  // Convert the rendered markdown to a Cheerio object\r\n  let nodes = parseHTML(renderedMarkdown);\r\n  console.log(nodes);\r\n  // console.log(\"render\", renderedMarkdown)\r\n  // console.log(\"x cherrio\", x)\r\n  // console.log(x)\r\n  // let node = x('ul');\r\n\r\n  // console.log(\"Text end\", node);\r\n\r\n\r\nif (nodes === null) {\r\n  console.log('parseHTML(renderedMarkdown) returned null');\r\n} else {\r\n  nodes.forEach(node => {\r\n    if (node.name == \"ul\") {\r\n      console.log(\"ul node\", node);\r\n      processUlNode(node);\r\n      node = convertToBarGraph(node);\r\n      console.log(\"after process\", node);\r\n          renderedMarkdown = convertBackToHtml([node]);\r\n\r\n    }\r\n    // renderedMarkdown = convertBackToHtml(nodes);\r\n\r\n  });\r\n}\r\n// Process the Cheerio object$ = processHTML($); // Cast Root to CheerioAPI\r\n\r\n// Convert the Cheerio object back to a string\r\n// renderedMarkdown = x.html();\r\n\r\n  const beautifiedHTML = html_beautify(renderedMarkdown, { indent_size: 2 });\r\n  \r\n  const highlightedHTML = Prism.highlight(beautifiedHTML, Prism.languages.markup, 'markup');\r\n\r\n  return (\r\n    <div>\r\n      <Row gutter={[16, 16]}>\r\n        <Col span={12}>\r\n          <div dangerouslySetInnerHTML={{ __html: renderedMarkdown }} />\r\n        </Col>\r\n        <Col span={12}>\r\n          <pre className=\"language-markup\"><code dangerouslySetInnerHTML={{ __html: highlightedHTML }} /></pre>\r\n        </Col>\r\n      </Row>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MarkdownRenderer;\r\n","import { NodeOrText, DomElement } from './Node';\r\n\r\nexport function convertToBarGraph(node: NodeOrText): NodeOrText {\r\n  // Check if the node is a MbNode and is an 'ul' with the 'bargraph' attribute\r\n  if ('name' in node && node.name === 'ul' && node.attribs && node.attribs['bargraph'] !== undefined) {\r\n\r\n    // Define the dimensions of the bar graph\r\n    let barWidth = 40;\r\n    let barSpacing = 10;\r\n    let barHeightMultiplier = 3;  // Arbitrary unit for visualizing the bar heights\r\n    let svgWidth = (node.children?.length || 0) * (barWidth + barSpacing);\r\n\r\n    // Initialize max height variable\r\n    let maxBarHeight = 0;\r\n\r\n    // Initialize an empty array for the new children\r\n    let newChildren: NodeOrText[] = [];\r\n\r\n    // Define padding\r\n    let padding = 20;\r\n\r\n    // First pass to determine the maximum bar height\r\n    node.children?.forEach((child) => {\r\n      if ('name' in child && child.name === 'li' && child.attribs && child.attribs['value']) {\r\n        let barHeight = Number(child.attribs['value']) * barHeightMultiplier;\r\n        if (barHeight > maxBarHeight) {\r\n          maxBarHeight = barHeight;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Second pass to create the SVG rectangles\r\n    node.children?.forEach((child, i) => {\r\n      if ('name' in child && child.name === 'li' && child.attribs && child.attribs['value']) {\r\n        let barHeight = Number(child.attribs['value']) * barHeightMultiplier;\r\n        let x = i * (barWidth + barSpacing);\r\n        let y = padding + (maxBarHeight - barHeight);  // Add padding to the y position\r\n\r\n        // Create a rectangle for the bar\r\n        let rectNode: NodeOrText = {\r\n          type: 'tag',\r\n          name: 'rect',\r\n          attribs: {\r\n            'x': x.toString(),\r\n            'y': y.toString(),\r\n            'width': barWidth.toString(),\r\n            'height': barHeight.toString(),\r\n            'fill': 'red'\r\n          },\r\n          children: [],\r\n          parent: node,\r\n          prev: i > 0 ? newChildren[newChildren.length - 1] : undefined,  // Set the previous sibling if it exists\r\n          next: undefined  // This will be set in the next iteration\r\n        };\r\n\r\n        // If there is a previous sibling, set its 'next' link to this node\r\n        if (i > 0 && newChildren[newChildren.length - 1] && 'next' in newChildren[newChildren.length - 1]) {\r\n          newChildren[newChildren.length - 1].next = rectNode;\r\n        }\r\n\r\n        // Add the rectangle to the new children\r\n        newChildren.push(rectNode);\r\n\r\n        // Check if the child has text data for a label\r\n        if ('children' in child && child.children && child.children.length > 0 && 'data' in child.children[0]) {\r\n          // Create a text SVG element for the label\r\n          let textNode: NodeOrText = {\r\n            type: 'tag',\r\n            name: 'text',\r\n            attribs: {\r\n              'x': x.toString(),\r\n              'y': (padding + maxBarHeight + 20).toString(),  // Add padding to the y position of the label\r\n              'fill': 'black'\r\n            },\r\n            children: [{\r\n              type: 'text',\r\n              data: child.children[0].data\r\n            }],\r\n            parent: node,\r\n            prev: newChildren[newChildren.length - 1],  // Set the previous sibling to the rectangle\r\n            next: undefined  // This will be set in the next iteration\r\n          };\r\n\r\n          // Set the rectangle's 'next' link to this node\r\n          if ('next' in rectNode) {\r\n            rectNode.next = textNode;\r\n          }\r\n\r\n          // Add the text node to the new children\r\n          newChildren.push(textNode);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Now that we've computed the max height, set the SVG height (additional 50 units for labels and padding)\r\n    node.attribs = {\r\n      'width': svgWidth.toString(),\r\n      'height': (padding * 2 + maxBarHeight + 30).toString()  // Add padding to the total height\r\n    };\r\n\r\n    // Change the node's name to 'svg' and replace its children with the new children\r\n    node.name = 'svg';\r\n    node.children = newChildren;\r\n  }\r\n\r\n  // Return the node (modified or not)\r\n  return node;\r\n}\r\n","import React, { useState } from 'react';\r\nimport { Input } from 'antd';\r\nimport MarkdownRenderer from 'components/markdown/MarkdownRenderer';\r\n\r\nconst { TextArea } = Input;\r\n\r\nconst MarkdownEditorPage: React.FC = () => {\r\n  const [markdown, setMarkdown] = useState(`\r\n- item 1\r\n- item 2 {icon=\"https://spirify.azurewebsites.net/icon-512.png\"}\r\n`);\r\n\r\n  return (\r\n    <div>\r\n      <TextArea\r\n        value={markdown}\r\n        onChange={(e) => setMarkdown(e.target.value)}\r\n        placeholder=\"Write some markdown here...\"\r\n        rows={4}\r\n      />\r\n      <MarkdownRenderer markdown={markdown} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MarkdownEditorPage;\r\n"],"names":["convertBackToHtml","nodes","$","cheerio","body","forEach","node","element","concat","name","attr","attribs","children","append","data","html","updateNodeStyle","styleObject","_node$attribs","style","split","reduce","acc","rule","_rule$split$map","map","str","trim","_rule$split$map2","_slicedToArray","property","value","getStyleObject","Object","entries","_ref","_ref2","join","createStyleString","updateLiChildren","child","parentIconAttributes","defaultLiIconAttributes","_child$attribs","_child$attribs2","_child$attribs3","_child$attribs4","_child$attribs5","_child$attribs6","icon","iconSize","size","className","class","parent","arguments","length","undefined","isNumber","isString","test","fontSize","Number","slice","Math","max","imageSize","squareSize","getSize","iChild","emoji","EmojiConvertor","replace_mode","allow_native","emojiString","unicodeEmoji","replace_colons","isEmoji","isImage","defaultSize","type","_objectSpread","next","prev","_icon$split$pop","_divNode$children","altText","pop","divNode","imgNode","src","alt","push","createIChild","divChild","updateNodeRelations","md","MarkdownIt","use","MarkdownItAttrs","core","ruler","state","ulList","resultUl","tokens","token","index","_toConsumableArray","pTag","atIndex","curUl","attrs","newTokens","matchingUl","find","ul","level","markdown","renderedMarkdown","render","console","log","_node$attribs2","_node$children","iconUl","hasIconInChildren","_child$attribs7","_node$attribs3","_node$attribs4","_node$attribs5","_node$attribs6","_node$attribs7","iconAttributes","_hasIconInChildren$at","_hasIconInChildren$at2","_hasIconInChildren$at3","_node$children2","defaultLiIcon","processUlNode","_node$children3","svgWidth","maxBarHeight","newChildren","barHeight","i","x","y","rectNode","toString","textNode","padding","convertToBarGraph","beautifiedHTML","html_beautify","indent_size","highlightedHTML","Prism","_jsx","_jsxs","Row","gutter","Col","span","dangerouslySetInnerHTML","__html","TextArea","Input","_useState","useState","_useState2","setMarkdown","onChange","e","target","placeholder","rows","MarkdownRenderer"],"sourceRoot":""}